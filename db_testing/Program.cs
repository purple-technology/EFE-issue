using Npgsql;
using System.Collections.Generic;
using System.Linq;
using TestingORM.Model;
using TestingORM.DAL;
using System;
using System.Text;

namespace db_testing
{
	class Program
	{
		static void Main(string[] args)
		{
			using (var context = new TestingContext()) {
				context.Configuration.AutoDetectChangesEnabled = false;
				context.Configuration.LazyLoadingEnabled = false;

				const int count = 100000;

				// PROBLEM: The second iteration (with UPDATE) takes really long time (~1.5 minutes) or times out (first iteration (INSERT only) creates db records in few seconds)
				for (int i = 0; i < 2; ++i) {
					TestServersEFE(context, count, i);
				}

				for (int i = 0; i < 2; ++i) {
					TestServersStr(context, count, i);
				}
			}
		}

		private static void TestServersEFE(TestingContext context, int count, int iteration)
		{
			// prepare data
			List<Server> servers = new List<Server>(count);
			for (var j = 0; j < count; ++j) {
				servers.Add(new Server {
					Name = "name_" + j,
					Data = "data_" + iteration + "_" + j,
				});
			}

			// merge based on 'name'
			context.BulkMerge(servers, options => {
				options.ColumnPrimaryKeyExpression = server => server.Name;
				//options.AutoMapOutputDirection = false; // Cannot use this as I need the primary key generated on the server
				options.Log = s => Console.WriteLine(s);
			});
		}

		private static void TestServersStr(TestingContext context, int count, int iteration)
		{
			int batchSize = Math.Min(5000, count); // send data to server in batches

			// PREPARE DATA
			List<Server> servers = new List<Server>(count);
			for (var i = 0; i < count; ++i) {
				servers.Add(new Server {
					Name = "name_" + i,
					Data = "data_" + iteration + "_" + i,
				});
			}

			// PREPARE QUERY
			var values = new StringBuilder();
			for (var i = 0; i < batchSize; ++i) {
				if (0 < i) {
					values.Append(" UNION ALL ");
				}
				values.Append($"SELECT @name_{i} AS \"Name\", @data_{i} AS \"Data\"");
			}

			// difference in UPDATE command against query generated by EFE
			// FROM "public"."Server" AS OldValue, (...
			// the '"public"."Server" AS OldValue,' part is missing here
			var query =
				"UPDATE \"public\".\"Server\" AS DestinationTable SET \"Data\" = StagingTable.\"Data\" " +
				$"FROM ({values}) AS StagingTable " +
				"WHERE DestinationTable.\"Name\" = StagingTable.\"Name\" " +
				"RETURNING DestinationTable.\"ServerID\";" +
				"INSERT INTO \"public\".\"Server\" AS DestinationTable (\"Name\", \"Data\") SELECT \"Name\", \"Data\" " +
				$"FROM ({values}) AS StagingTable " +
				"WHERE NOT EXISTS(SELECT 1 FROM \"public\".\"Server\" AS DestinationTable WHERE DestinationTable.\"Name\" = StagingTable.\"Name\") " +
				"RETURNING DestinationTable.\"ServerID\";";

			// PREPARE COMMAND
			var cmd = new NpgsqlCommand {
				Connection = context.Database.Connection as NpgsqlConnection,
				CommandType = System.Data.CommandType.Text,
				CommandText = query
			};
			// COMMAND PARAMETERS
			var cmdParams = new List<NpgsqlParameter>(batchSize * 2);
			for (var i = 0; i < batchSize; ++i) {
				cmdParams.Add(new NpgsqlParameter {
					ParameterName = $"@name_{i}",
					NpgsqlDbType = NpgsqlTypes.NpgsqlDbType.Varchar,
				});
				cmdParams.Add(new NpgsqlParameter {
					ParameterName = $"@data_{i}",
					NpgsqlDbType = NpgsqlTypes.NpgsqlDbType.Varchar,
				});
			}
			cmd.Parameters.AddRange(cmdParams.ToArray());

			// BATCH INFO
			var batchCount = count / batchSize;
			if (batchCount * batchSize < count) {
				batchCount++;
			}
			var currentBatch = 0;

			// QUERY EXECUTION
			using (var transaction = context.Database.BeginTransaction()) {
				try {
					cmd.Prepare(); // prepare parametrized command

					while (currentBatch < batchCount) {
						// PREPARE QUERY PARAMS
						var batchData = servers.Skip(currentBatch * batchSize).Take(batchSize).Select(server => new { server.Name, server.Data }).ToArray();
						for (var i = 0; i < batchData.Count(); ++i) {
							cmd.Parameters[$"@name_{i}"].Value = batchData[i].Name;
							cmd.Parameters[$"@data_{i}"].Value = batchData[i].Data;
						}
						// EXECUTE
						using (var reader = cmd.ExecuteReader()) {
						}

						currentBatch++;
					}

					transaction.Commit();
				}
				catch {
					transaction.Rollback();
					throw;
				}
			}
		}
	}
}
